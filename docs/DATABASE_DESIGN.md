
# Simple Log Service - Database Design

**Version:** 2.0  
**Last Updated:** 2026-02-02  
**Status:** Production

---

## Table of Contents

1. [Overview](#overview)
2. [Database Selection](#database-selection)
3. [Schema Design](#schema-design)
4. [Access Patterns](#access-patterns)
5. [Indexing Strategy](#indexing-strategy)
6. [Data Modeling](#data-modeling)
7. [Performance Optimization](#performance-optimization)
8. [Backup & Recovery](#backup--recovery)
9. [Future Enhancements](#future-enhancements)

---

## Overview

Simple Log Service uses Amazon DynamoDB as its primary data store. This document explains the design decisions, schema structure, and optimization strategies.

**Database:** Amazon DynamoDB  
**Table Name:** `simple-log-service-logs-prod`  
**Region:** us-east-1  
**Billing Mode:** On-Demand

---

## Database Selection

### Why DynamoDB?

**Requirements:**
- High write throughput (1000+ logs/second)
- Low latency reads (< 10ms)
- Automatic scaling
- No server management
- Built-in encryption
- Point-in-time recovery

**Comparison Matrix:**

| Feature | DynamoDB | RDS (PostgreSQL) | DocumentDB | ElastiCache |
|---------|----------|------------------|------------|-------------|
| **Latency** | < 10ms | 10-50ms | 10-30ms | < 1ms |
| **Scaling** | Automatic | Manual | Manual | Manual |
| **Management** | Serverless | Managed | Managed | Managed |
| **Cost (Low Volume)** | $2/month | $15/month | $50/month | $12/month |
| **Cost (High Volume)** | $65/month | $100/month | $150/month | $50/month |
| **Encryption** | Built-in | Built-in | Built-in | Optional |
| **Backup** | Automatic | Manual | Manual | Manual |
| **Query Flexibility** | Limited | High | High | Limited |

**Decision:** DynamoDB selected for:
- ✅ Single-digit millisecond latency
- ✅ Automatic scaling (no capacity planning)
- ✅ Serverless (no server management)
- ✅ Cost-effective for variable workloads
- ✅ Built-in encryption and backups

**Trade-offs:**
- ⚠️ Limited query patterns (partition + sort key only)
- ⚠️ No complex joins or aggregations
- ⚠️ Eventual consistency by default

---

## Schema Design

### Table Structure

**Table Name:** `simple-log-service-logs-prod`

**Primary Key:**
- **Partition Key:** `service_name` (String)
- **Sort Key:** `timestamp` (String, ISO 8601 format)

**Attributes:**
- `log_id` (String) - UUID v4, unique identifier
- `log_type` (String) - application, system, audit, security
- `level` (String) - INFO, WARN, ERROR, DEBUG, TRACE
- `message` (String) - Log message content (max 400 KB)
- `metadata` (Map) - Optional additional data (JSON)

**Example Item:**
```json
{
  "service_name": "api-gateway",
  "timestamp": "2026-02-02T10:30:45.123Z",
  "log_id": "550e8400-e29b-41d4-a716-446655440000",
  "log_type": "application",
  "level": "INFO",
  "message": "Request processed successfully",
  "metadata": {
    "user_id": "12345",
    "request_id": "abc-def-ghi",
    "duration_ms": 150,
    "status_code": 200
  }
}
```

---

### Key Design Decisions

#### 1. Partition Key: `service_name`

**Rationale:**
- Logs are naturally grouped by service
- Enables efficient queries by service
- Distributes load across partitions
- Supports multi-tenant architecture

**Considerations:**
- Hot partitions if one service dominates traffic
- Mitigation: Use composite partition key (service_name#date) for high-volume services

---

#### 2. Sort Key: `timestamp`

**Rationale:**
- Logs are time-series data
- Enables range queries (last 24 hours, last week)
- Natural sort order (newest first)
- Supports pagination

**Format:** ISO 8601 with milliseconds
- Example: `2026-02-02T10:30:45.123Z`
- Sortable as string
- Human-readable
- Timezone-aware (UTC)

---

#### 3. Attribute: `log_id`

**Rationale:**
- Unique identifier for each log entry
- Enables idempotent writes
- Supports deduplication
- Facilitates log correlation

**Format:** UUID v4
- Example: `550e8400-e29b-41d4-a716-446655440000`
- Globally unique
- No collision risk
- Generated by Lambda

---

#### 4. Attribute: `metadata`

**Rationale:**
- Flexible schema for additional data
- No schema changes required
- Supports diverse log types
- Enables rich context

**Structure:** JSON Map
- Nested objects supported
- Max size: 400 KB (DynamoDB item limit)
- Optional field

---

## Access Patterns

### Primary Access Patterns

**1. Query logs by service (last 24 hours)**
```python
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway') &
                          Key('timestamp').between(start_time, end_time)
)
```

**Performance:**
- Latency: < 10ms
- Cost: 1 RCU per 4 KB
- Scalability: Unlimited (within partition limits)

---

**2. Query logs by service and level**
```python
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway') &
                          Key('timestamp').between(start_time, end_time),
    FilterExpression=Attr('level').eq('ERROR')
)
```

**Performance:**
- Latency: < 20ms (filter applied after query)
- Cost: Same as query (filter doesn't reduce RCU)
- Scalability: Good (filter in application layer)

---

**3. Scan all recent logs (last 1 hour)**
```python
response = table.scan(
    FilterExpression=Attr('timestamp').gte(one_hour_ago)
)
```

**Performance:**
- Latency: 100-500ms (depends on table size)
- Cost: Scans entire table (expensive)
- Scalability: Poor (avoid for large tables)

**Recommendation:** Use sparingly, prefer query with service_name

---

### Secondary Access Patterns (Future)

**4. Query logs by log_id (exact match)**
- **Solution:** Global Secondary Index (GSI) on `log_id`
- **Cost:** Additional storage + RCU/WCU
- **Use case:** Log correlation, debugging

**5. Query logs by level (all services)**
- **Solution:** GSI on `level` (partition key) + `timestamp` (sort key)
- **Cost:** Additional storage + RCU/WCU
- **Use case:** Error monitoring, alerting

**6. Query logs by metadata field (e.g., user_id)**
- **Solution:** GSI on `metadata.user_id` (sparse index)
- **Cost:** Additional storage + RCU/WCU
- **Use case:** User activity tracking, compliance

---

## Indexing Strategy

### Current Indexes

**Primary Index:**
- Partition Key: `service_name`
- Sort Key: `timestamp`
- Projection: ALL (all attributes)

**No Secondary Indexes (v1.0)**
- Keeps costs low
- Simplifies schema
- Sufficient for current access patterns

---

### Future Indexes (Planned)

**GSI 1: Log ID Index**
```hcl
resource "aws_dynamodb_table" "logs" {
  global_secondary_index {
    name               = "log-id-index"
    hash_key           = "log_id"
    projection_type    = "ALL"
    read_capacity      = 5
    write_capacity     = 5
  }
}
```

**Use Case:** Exact log lookup by ID

---

**GSI 2: Level Index**
```hcl
resource "aws_dynamodb_table" "logs" {
  global_secondary_index {
    name               = "level-timestamp-index"
    hash_key           = "level"
    range_key          = "timestamp"
    projection_type    = "ALL"
    read_capacity      = 5
    write_capacity     = 5
  }
}
```

**Use Case:** Query all ERROR logs across services

---

**GSI 3: Log Type Index**
```hcl
resource "aws_dynamodb_table" "logs" {
  global_secondary_index {
    name               = "log-type-timestamp-index"
    hash_key           = "log_type"
    range_key          = "timestamp"
    projection_type    = "ALL"
    read_capacity      = 5
    write_capacity     = 5
  }
}
```

**Use Case:** Query by log type (audit, security, etc.)

---

## Data Modeling

### Item Size Optimization

**DynamoDB Limits:**
- Max item size: 400 KB
- Attribute name size counts toward limit
- Nested attributes supported

**Optimization Strategies:**

**1. Short Attribute Names**
```json
// Bad (verbose)
{
  "service_name": "api-gateway",
  "timestamp": "2026-02-02T10:30:45.123Z",
  "log_message": "Request processed"
}

// Good (concise)
{
  "svc": "api-gateway",
  "ts": "2026-02-02T10:30:45.123Z",
  "msg": "Request processed"
}
```

**Savings:** ~30% reduction in item size

---

**2. Compress Large Messages**
```python
import gzip
import base64

# Compress message if > 10 KB
if len(message) > 10240:
    compressed = gzip.compress(message.encode())
    message = base64.b64encode(compressed).decode()
    metadata['compressed'] = True
```

**Savings:** 70-90% reduction for text data

---

**3. Store Large Payloads in S3**
```python
# If message > 100 KB, store in S3
if len(message) > 102400:
    s3_key = f"logs/{log_id}.json"
    s3.put_object(Bucket='log-payloads', Key=s3_key, Body=message)
    message = f"s3://{bucket}/{s3_key}"
    metadata['s3_stored'] = True
```

**Savings:** Unlimited message size, lower DynamoDB costs

---

### Time-Series Data Optimization

**Problem:** Old logs rarely accessed, but consume storage

**Solution 1: Time-to-Live (TTL)**
```hcl
resource "aws_dynamodb_table" "logs" {
  ttl {
    attribute_name = "expiration_time"
    enabled        = true
  }
}
```

**Implementation:**
```python
# Set expiration to 90 days from now
expiration_time = int(time.time()) + (90 * 24 * 60 * 60)
item['expiration_time'] = expiration_time
```

**Benefits:**
- Automatic deletion (no Lambda required)
- No cost for deletions
- Reduces storage costs

---

**Solution 2: Archive to S3**
```python
# DynamoDB Streams + Lambda
def archive_old_logs(event):
    for record in event['Records']:
        if record['eventName'] == 'REMOVE':  # TTL deletion
            log_item = record['dynamodb']['OldImage']
            s3_key = f"archive/{log_item['service_name']}/{log_item['timestamp']}.json"
            s3.put_object(Bucket='log-archive', Key=s3_key, Body=json.dumps(log_item))
```

**Benefits:**
- Long-term retention (years)
- 90% cost reduction (S3 vs. DynamoDB)
- Query with Athena

---

## Performance Optimization

### Read Performance

**1. Use Query Instead of Scan**
```python
# Bad (scans entire table)
response = table.scan(
    FilterExpression=Attr('service_name').eq('api-gateway')
)

# Good (queries specific partition)
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway')
)
```

**Performance Improvement:** 10-100x faster

---

**2. Use Consistent Reads Sparingly**
```python
# Default (eventually consistent, faster, cheaper)
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway')
)

# Strongly consistent (slower, 2x cost)
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway'),
    ConsistentRead=True
)
```

**Recommendation:** Use eventually consistent for logs (acceptable 1-2 second delay)

---

**3. Use Projection Expressions**
```python
# Bad (retrieves all attributes)
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway')
)

# Good (retrieves only needed attributes)
response = table.query(
    KeyConditionExpression=Key('service_name').eq('api-gateway'),
    ProjectionExpression='log_id, timestamp, level, message'
)
```

**Performance Improvement:** 50-70% reduction in data transfer

---

### Write Performance

**1. Use Batch Writes**
```python
# Bad (individual writes)
for log in logs:
    table.put_item(Item=log)

# Good (batch writes, up to 25 items)
with table.
